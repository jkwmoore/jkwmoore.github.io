<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://blog.jkwmoore.dev/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jkwmoore.dev/" rel="alternate" type="text/html" /><updated>2025-04-01T01:46:41+00:00</updated><id>https://blog.jkwmoore.dev/feed.xml</id><title type="html">blog.jkwmoore.dev</title><subtitle>A minimal blog I might write some stuff on.
</subtitle><author><name>James Moore</name></author><entry><title type="html">Puppet PDK testing: Show rendered templates while testing locally</title><link href="https://blog.jkwmoore.dev/puppet-pdk-testing-show-rendered-templates-while-testing-locally.html" rel="alternate" type="text/html" title="Puppet PDK testing: Show rendered templates while testing locally" /><published>2025-03-13T00:00:00+00:00</published><updated>2025-03-13T00:00:00+00:00</updated><id>https://blog.jkwmoore.dev/Puppet-PDK-testing-show-rendered-templates-while-testing-locally</id><content type="html" xml:base="https://blog.jkwmoore.dev/puppet-pdk-testing-show-rendered-templates-while-testing-locally.html"><![CDATA[<h3 id="what-was-the-problem">What was the problem?</h3>

<p>I want to see what my templates are rendering while doing local testing. This is pretty helpful especially if you’ve got some hiera data being used
that you want to ensure is being rendered correctly.</p>

<h3 id="how-can-we-show-the-rendered-templates-during-pdk-testing">How can we show the rendered templates during PDK testing?</h3>

<p>Turns out this is pretty easy (so long as you like cheap and kind of nasty) and needs only the most basic changes to your class’s spec file.</p>

<p>e.g. to show a specific template’s content via the CLI output, add the following in your class spec file, <code class="language-plaintext highlighter-rouge">spec/classes/myclass_spec.rb</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s1">'mymodule::myclass'</span> <span class="k">do</span>
  <span class="n">on_supported_os</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">os</span><span class="p">,</span> <span class="n">os_facts</span><span class="o">|</span>
    <span class="n">context</span> <span class="s2">"on </span><span class="si">#{</span><span class="n">os</span><span class="si">}</span><span class="s2">"</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:facts</span><span class="p">)</span> <span class="p">{</span> <span class="n">os_facts</span> <span class="p">}</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">is_expected</span><span class="p">.</span><span class="nf">to</span> <span class="n">compile</span> <span class="p">}</span>

      <span class="c1"># To visualise the output of the /the/path/to/your/defined/file/resource.txt template during a PDK run, </span>
      <span class="c1"># set TEMPLATE_DEBUG=true in your shell environment before running ``pdk test unit``.</span>
      <span class="c1"># i.e. ``TEMPLATE_DEBUG=true pdk test unit``</span>

      <span class="n">it</span> <span class="s1">'echoes rendered template content with OS info and markers (if TEMPLATE_DEBUG is set true)'</span> <span class="k">do</span>
        <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'TEMPLATE_DEBUG'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'true'</span>
          <span class="n">content</span> <span class="o">=</span> <span class="n">catalogue</span><span class="p">.</span><span class="nf">resource</span><span class="p">(</span><span class="s1">'file'</span><span class="p">,</span> <span class="s1">'/the/path/to/your/defined/file/resource.txt'</span><span class="p">).</span><span class="nf">send</span><span class="p">(</span><span class="ss">:parameters</span><span class="p">)[</span><span class="ss">:content</span><span class="p">]</span>
          <span class="nb">puts</span> <span class="s2">"################################ Generated /the/path/to/your/defined/file/resource.txt content on: </span><span class="si">#{</span><span class="n">os</span><span class="si">}</span><span class="s2">"</span>
          <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">content</span><span class="si">}</span><span class="s2">"</span>
          <span class="nb">puts</span> <span class="s2">"################################"</span>
        <span class="k">end</span>
      <span class="k">end</span>

    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This might be pretty noisy if you’re PDK testing against a lot of OSes with multiple templates though <code class="language-plaintext highlighter-rouge">¯\_(ツ)_/¯</code>, so I
figure why not be a bit more clever about it and simply render out all the template content to a subdirectory for inspection?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="n">describe</span> <span class="s1">'mymodule::myclass'</span> <span class="k">do</span>
  <span class="n">on_supported_os</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">os</span><span class="p">,</span> <span class="n">os_facts</span><span class="o">|</span>
    <span class="n">context</span> <span class="s2">"on </span><span class="si">#{</span><span class="n">os</span><span class="si">}</span><span class="s2">"</span> <span class="k">do</span>
      <span class="n">let</span><span class="p">(</span><span class="ss">:facts</span><span class="p">)</span> <span class="p">{</span> <span class="n">os_facts</span> <span class="p">}</span>

      <span class="n">it</span> <span class="p">{</span> <span class="n">is_expected</span><span class="p">.</span><span class="nf">to</span> <span class="n">compile</span> <span class="p">}</span>

      <span class="c1"># To render out all templated content during a PDK run to the ``rendered_templates`` subdirectory,</span>
      <span class="c1"># set TEMPLATE_DEBUG=true in your shell environment before running ``pdk test unit``.</span>
      <span class="c1"># i.e. ``TEMPLATE_DEBUG=true pdk test unit``</span>

      <span class="n">it</span> <span class="s1">'writes generated file content to rendered_templates directory per OS version'</span> <span class="k">do</span>
        <span class="c1"># Check if TEMPLATE_DEBUG is set to 'true'</span>
        <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'TEMPLATE_DEBUG'</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'true'</span>
          <span class="n">os_name</span> <span class="o">=</span> <span class="n">facts</span><span class="p">[</span><span class="ss">:os</span><span class="p">][</span><span class="s1">'name'</span><span class="p">].</span><span class="nf">downcase</span>
          <span class="n">os_version</span> <span class="o">=</span> <span class="n">facts</span><span class="p">[</span><span class="ss">:os</span><span class="p">][</span><span class="s1">'release'</span><span class="p">][</span><span class="s1">'full'</span><span class="p">]</span>
          <span class="c1"># Write out the content per OS version</span>
          <span class="n">base_path</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'rendered_templates'</span><span class="p">,</span> <span class="s2">"</span><span class="si">#{</span><span class="n">os_name</span><span class="si">}</span><span class="s2">-</span><span class="si">#{</span><span class="n">os_version</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
      
          <span class="n">catalogue</span><span class="p">.</span><span class="nf">resources</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">resource</span><span class="o">|</span>
            <span class="c1"># Only process 'File' resources with a valid path.</span>
            <span class="c1"># This way we don't try to dump directories.</span>
            <span class="k">next</span> <span class="k">unless</span> <span class="n">resource</span><span class="p">.</span><span class="nf">type</span> <span class="o">==</span> <span class="s1">'File'</span>

            <span class="n">path</span> <span class="o">=</span> <span class="n">resource</span><span class="p">[</span><span class="ss">:path</span><span class="p">]</span> <span class="o">||</span> <span class="n">resource</span><span class="p">.</span><span class="nf">title</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">resource</span><span class="p">[</span><span class="ss">:content</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">path</span> <span class="o">&amp;&amp;</span> <span class="n">content</span>
              <span class="n">output_path</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">base_path</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
      
              <span class="c1"># Create the directory if it doesn't exist</span>
              <span class="no">FileUtils</span><span class="p">.</span><span class="nf">mkdir_p</span><span class="p">(</span><span class="no">File</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="n">output_path</span><span class="p">))</span>

              <span class="c1"># Write the content to the file</span>
              <span class="no">File</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">content</span><span class="p">)</span>
              <span class="nb">puts</span> <span class="s2">"✅ Wrote content to: </span><span class="si">#{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">"</span>
            <span class="k">elsif</span> <span class="n">path</span>
              <span class="c1"># Note - if the content is sourced from a file, the resource catalog does not have a content</span>
              <span class="c1"># element for us to render out.</span>
              <span class="nb">puts</span> <span class="s2">"⚠️ No content for: </span><span class="si">#{</span><span class="n">path</span><span class="si">}</span><span class="s2"> (likely sourced)"</span>
            <span class="k">end</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>

    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>I’ve found this to be a useful method during PDK testing for confirming correct template rendering while working with hiera data (structures).</p>

<p>This has also been particularly useful for visualising the created directories, files and content if the classes you are creating are calling 
other classes, as their outputs will also be rendered!</p>

<p>This is all very helpful for determining and implementing new spec tests for your classes, e.g. for adding tests to automatically validate
template / file contents generated by the subordinate classes.</p>

<p>GLHF!</p>

<p>JKWM.</p>]]></content><author><name>James Moore</name></author><category term="Puppet" /><summary type="html"><![CDATA[What was the problem?]]></summary></entry><entry><title type="html">Puppet PDK testing when using hiera eyaml</title><link href="https://blog.jkwmoore.dev/puppet-eyaml-and-pdk-testing.html" rel="alternate" type="text/html" title="Puppet PDK testing when using hiera eyaml" /><published>2025-03-07T00:00:00+00:00</published><updated>2025-03-07T00:00:00+00:00</updated><id>https://blog.jkwmoore.dev/Puppet-eyaml-and-PDK-testing</id><content type="html" xml:base="https://blog.jkwmoore.dev/puppet-eyaml-and-pdk-testing.html"><![CDATA[<blockquote>
  <p>Warning: I cannot claim to be a Puppet backend expert but I managed to get past PDK testing issues as below.</p>
</blockquote>

<hr />

<h3 id="what-was-the-problem">What was the problem?</h3>

<p>PDK tests are failing because I don’t have the keys necessary to decrypt the secrets while testing locally. 
I also do not want to keep the encryption keys locally, nor anywhere except the PuppetServer.</p>

<p>So what do these errors look like?</p>

<p>Well, I am trying to use the following from my hiera <code class="language-plaintext highlighter-rouge">common.eyaml</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">myclass::mysecretstring: ENC[PKCS7,MYENCRYPTEDSECRETSTRINGCONTENT]</span>
</code></pre></div></div>

<p>And PDK gives me:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1<span class="o">)</span> myclass::mymanifest on redhat-8-x86_64 is expected to compile into a catalogue without dependency cycles
     Failure/Error: it <span class="o">{</span> is_expected.to compile <span class="o">}</span>
       error during compilation: Function lookup<span class="o">()</span> did not find a value <span class="k">for </span>the name <span class="s1">'myclass::mysecretstring'</span> on node my_dev_machine.local
     <span class="c"># ./spec/classes/mymanifest_spec.rb:10:in `block (4 levels) in &lt;top (required)&gt;'</span>
</code></pre></div></div>

<h3 id="how-did-i-sort-this">How did I sort this?</h3>

<p>I added overrides to the spec test used for the class.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="n">before</span> <span class="k">do</span>
        <span class="n">allow</span><span class="p">(</span><span class="no">Puppet</span><span class="o">::</span><span class="no">Pops</span><span class="o">::</span><span class="no">Lookup</span><span class="p">).</span><span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="ss">:lookup</span><span class="p">).</span><span class="nf">and_call_original</span>  <span class="c1"># Allow normal lookups</span>

        <span class="n">allow</span><span class="p">(</span><span class="no">Puppet</span><span class="o">::</span><span class="no">Pops</span><span class="o">::</span><span class="no">Lookup</span><span class="p">).</span><span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="ss">:lookup</span><span class="p">)</span>
          <span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="s1">'myclass::mysecretstring'</span><span class="p">,</span> <span class="n">anything</span><span class="p">,</span> <span class="n">anything</span><span class="p">,</span> <span class="n">anything</span><span class="p">,</span> <span class="n">anything</span><span class="p">,</span> <span class="n">anything</span><span class="p">)</span>
          <span class="p">.</span><span class="nf">and_return</span><span class="p">(</span><span class="s1">'MOCKED_VALUE_STRING'</span><span class="p">)</span>
      <span class="k">end</span>
</code></pre></div></div>

<h3 id="why-do-i-think-this-works">Why do I think this works</h3>

<p>Aside of the fact I tested it and it appears to do what I wanted, see below:</p>

<h4 id="what-is-puppetpopslookup"><strong>What is <code class="language-plaintext highlighter-rouge">Puppet::Pops::Lookup</code>?</strong></h4>
<ul>
  <li>Puppet uses <strong>Hiera</strong> to retrieve values from a hierarchy of data sources.</li>
  <li>When a class requests a variable via <code class="language-plaintext highlighter-rouge">lookup('some_variable')</code>, Puppet internally calls <code class="language-plaintext highlighter-rouge">Puppet::Pops::Lookup.lookup('some_variable', ...)</code>.</li>
  <li>This function searches for the requested key across the defined Hiera hierarchy.</li>
  <li>https://www.rubydoc.info/gems/puppet/Puppet%2FPops%2FLookup.lookup</li>
</ul>

<p>For example, if the Puppet manifest has:</p>
<div class="language-puppet highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$mysecret</span> <span class="o">=</span> <span class="nf">lookup</span><span class="p">(</span><span class="s1">'myclass::mysecretstring'</span><span class="p">)</span>
</code></pre></div></div>
<p>Puppet will call:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Puppet</span><span class="o">::</span><span class="no">Pops</span><span class="o">::</span><span class="no">Lookup</span><span class="p">.</span><span class="nf">lookup</span><span class="p">(</span><span class="s1">'myclass::mysecretstring'</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div></div>
<p>and return the corresponding value from Hiera.</p>

<hr />

<h4 id="stub-only-the-problematic-lookup">Stub Only the Problematic Lookup</h4>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allow</span><span class="p">(</span><span class="no">Puppet</span><span class="o">::</span><span class="no">Pops</span><span class="o">::</span><span class="no">Lookup</span><span class="p">).</span><span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="ss">:lookup</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="s1">'myclass::mysecretstring'</span><span class="p">,</span> <span class="n">anything</span><span class="p">,</span> <span class="n">anything</span><span class="p">,</span> <span class="n">anything</span><span class="p">,</span> <span class="n">anything</span><span class="p">,</span> <span class="n">anything</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">and_return</span><span class="p">(</span><span class="s1">'MOCKED_VALUE_STRING'</span><span class="p">)</span>
</code></pre></div></div>
<ul>
  <li>This overrides lookups <strong>only</strong> for <code class="language-plaintext highlighter-rouge">myclass::mysecretstring</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">.with(...)</code> ensures that this stub only activates when the exact expected arguments are passed.</li>
  <li><code class="language-plaintext highlighter-rouge">.and_return('MOCKED_VALUE_STRING')</code> means that <strong>whenever Puppet tries to look up this variable, it will get <code class="language-plaintext highlighter-rouge">'MOCKED_VALUE_STRING'</code> instead of failing.</strong></li>
  <li>Depending on the expected data type for encrypted values, different mocking values may be required.</li>
</ul>

<p><strong>Effect:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">lookup('myclass::mysecretstring')</code> <strong>returns <code class="language-plaintext highlighter-rouge">'MOCKED_VALUE_STRING'</code> instead of failing</strong>.</li>
  <li>All other lookups still use Hiera data lookups as normal/expected.</li>
</ul>

<hr />

<h4 id="allow-normal-lookups">Allow Normal Lookups</h4>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">allow</span><span class="p">(</span><span class="no">Puppet</span><span class="o">::</span><span class="no">Pops</span><span class="o">::</span><span class="no">Lookup</span><span class="p">).</span><span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="ss">:lookup</span><span class="p">).</span><span class="nf">and_call_original</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">allow(...).to receive(:lookup)</code> tells RSpec to intercept calls to <code class="language-plaintext highlighter-rouge">Puppet::Pops::Lookup.lookup</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">.and_call_original</code> ensures that all other lookups (except the one we explicitly stub) continue to function normally.</li>
  <li>Without this, RSpec would try to stub all lookups, causing unexpected failures when other values like <code class="language-plaintext highlighter-rouge">myclass::someotherstring'</code> are requested from <code class="language-plaintext highlighter-rouge">common.yaml</code>.</li>
</ul>

<p><strong>Effect:</strong></p>
<ul>
  <li>Any <code class="language-plaintext highlighter-rouge">lookup('some_variable')</code> that is not explicitly stubbed will still perform its normal function.</li>
</ul>

<hr />

<h3 id="tldr-why-i-think-this-works-and-warnings"><strong>tl;dr Why I think this works and warnings</strong></h3>
<ol>
  <li><strong>Ensures normal lookups proceed without modification</strong> → The <code class="language-plaintext highlighter-rouge">.and_call_original</code> call ensures we do not break unrelated lookups.</li>
  <li><strong>Only stubs the problematic keys</strong> → This avoids unnecessary stubbing and allows normal Puppet behavior.</li>
  <li><strong>Prevents lookup errors in tests</strong> → PDK tests no longer fail due to “missing” Hiera data.</li>
  <li>Depending on the expected data type for encrypted values, different mocking values may be required.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Method: Puppet::Pops::Lookup.lookup</code> method documentation explicitly says:
  <code class="language-plaintext highlighter-rouge">This method is part of a private API. You should avoid using this method if possible, as it may be removed or be changed in the future.</code></li>
  <li>I am not a Ruby expert nor Puppet/PDK backend expert - here be dragons!</li>
</ol>

<p>GLHF!</p>

<p>JKWM.</p>]]></content><author><name>James Moore</name></author><category term="Puppet" /><summary type="html"><![CDATA[Warning: I cannot claim to be a Puppet backend expert but I managed to get past PDK testing issues as below.]]></summary></entry><entry><title type="html">First Post</title><link href="https://blog.jkwmoore.dev/first-post.html" rel="alternate" type="text/html" title="First Post" /><published>2025-02-15T00:00:00+00:00</published><updated>2025-02-15T00:00:00+00:00</updated><id>https://blog.jkwmoore.dev/first-post</id><content type="html" xml:base="https://blog.jkwmoore.dev/first-post.html"><![CDATA[<p>This post is a placeholder for the first post on my blog. I will update it with the actual content soon.</p>

<p>GLHF!</p>

<p>JKWM.</p>]]></content><author><name>James Moore</name></author><summary type="html"><![CDATA[This post is a placeholder for the first post on my blog. I will update it with the actual content soon.]]></summary></entry></feed>